/**
 * Generated by Scrooge
 *   version: 4.5.0
 *   rev: 014664de600267b36809bbc85225e26aec286216
 *   built at: 20160203-205352
 */
package com.jxjxgo.gamecenter.rpc.domain

import com.twitter.scrooge.{
  LazyTProtocol,
  TFieldBlob, ThriftException, ThriftStruct, ThriftStructCodec3, ThriftStructFieldInfo,
  ThriftStructMetaData, ThriftUtil}
import org.apache.thrift.protocol._
import org.apache.thrift.transport.{TMemoryBuffer, TTransport}
import java.nio.ByteBuffer
import java.util.Arrays
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.Builder
import scala.collection.mutable.{
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}


object GameTurnResponse extends ThriftStructCodec3[GameTurnResponse] {
  private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
  val Struct = new TStruct("GameTurnResponse")
  val GameIdField = new TField("gameId", TType.I64, 1)
  val GameIdFieldManifest = implicitly[Manifest[Long]]
  val GameTypeField = new TField("gameType", TType.I32, 2)
  val GameTypeFieldManifest = implicitly[Manifest[Int]]
  val DeviceTypeField = new TField("deviceType", TType.I32, 3)
  val DeviceTypeFieldManifest = implicitly[Manifest[Int]]
  val CardsField = new TField("cards", TType.STRING, 4)
  val CardsFieldManifest = implicitly[Manifest[String]]
  val LandlordCardsField = new TField("landlordCards", TType.STRING, 5)
  val LandlordCardsFieldManifest = implicitly[Manifest[String]]
  val BaseAmountField = new TField("baseAmount", TType.I32, 6)
  val BaseAmountFieldManifest = implicitly[Manifest[Int]]
  val MultiplesField = new TField("multiples", TType.I32, 7)
  val MultiplesFieldManifest = implicitly[Manifest[Int]]
  val PreviousNicknameField = new TField("previousNickname", TType.STRING, 8)
  val PreviousNicknameFieldManifest = implicitly[Manifest[String]]
  val PreviousCardsCountField = new TField("previousCardsCount", TType.I32, 9)
  val PreviousCardsCountFieldManifest = implicitly[Manifest[Int]]
  val NextNicknameField = new TField("nextNickname", TType.STRING, 10)
  val NextNicknameFieldManifest = implicitly[Manifest[String]]
  val NextCardsCountField = new TField("nextCardsCount", TType.I32, 11)
  val NextCardsCountFieldManifest = implicitly[Manifest[Int]]
  val ChoosingLandlordField = new TField("choosingLandlord", TType.BOOL, 12)
  val ChoosingLandlordFieldManifest = implicitly[Manifest[Boolean]]
  val LandlordField = new TField("landlord", TType.BOOL, 13)
  val LandlordFieldManifest = implicitly[Manifest[Boolean]]
  val TurnToPlayField = new TField("turnToPlay", TType.BOOL, 14)
  val TurnToPlayFieldManifest = implicitly[Manifest[Boolean]]

  /**
   * Field information in declaration order.
   */
  lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    new ThriftStructFieldInfo(
      GameIdField,
      false,
      false,
      GameIdFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      GameTypeField,
      false,
      false,
      GameTypeFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      DeviceTypeField,
      false,
      false,
      DeviceTypeFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      CardsField,
      false,
      false,
      CardsFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      LandlordCardsField,
      false,
      false,
      LandlordCardsFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      BaseAmountField,
      false,
      false,
      BaseAmountFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      MultiplesField,
      false,
      false,
      MultiplesFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      PreviousNicknameField,
      false,
      false,
      PreviousNicknameFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      PreviousCardsCountField,
      false,
      false,
      PreviousCardsCountFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      NextNicknameField,
      false,
      false,
      NextNicknameFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      NextCardsCountField,
      false,
      false,
      NextCardsCountFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      ChoosingLandlordField,
      false,
      false,
      ChoosingLandlordFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      LandlordField,
      false,
      false,
      LandlordFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      TurnToPlayField,
      false,
      false,
      TurnToPlayFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    )
  )

  lazy val structAnnotations: immutable$Map[String, String] =
    immutable$Map.empty[String, String]

  /**
   * Checks that all required fields are non-null.
   */
  def validate(_item: GameTurnResponse): Unit = {
  }

  def withoutPassthroughFields(original: GameTurnResponse): GameTurnResponse =
    new Immutable(
      gameId =
        {
          val field = original.gameId
          field
        },
      gameType =
        {
          val field = original.gameType
          field
        },
      deviceType =
        {
          val field = original.deviceType
          field
        },
      cards =
        {
          val field = original.cards
          field
        },
      landlordCards =
        {
          val field = original.landlordCards
          field
        },
      baseAmount =
        {
          val field = original.baseAmount
          field
        },
      multiples =
        {
          val field = original.multiples
          field
        },
      previousNickname =
        {
          val field = original.previousNickname
          field
        },
      previousCardsCount =
        {
          val field = original.previousCardsCount
          field
        },
      nextNickname =
        {
          val field = original.nextNickname
          field
        },
      nextCardsCount =
        {
          val field = original.nextCardsCount
          field
        },
      choosingLandlord =
        {
          val field = original.choosingLandlord
          field
        },
      landlord =
        {
          val field = original.landlord
          field
        },
      turnToPlay =
        {
          val field = original.turnToPlay
          field
        }
    )

  override def encode(_item: GameTurnResponse, _oproto: TProtocol): Unit = {
    _item.write(_oproto)
  }

  private[this] def lazyDecode(_iprot: LazyTProtocol): GameTurnResponse = {

    var gameId: Long = 0L
    var gameType: Int = 0
    var deviceType: Int = 0
    var cardsOffset: Int = -1
    var landlordCardsOffset: Int = -1
    var baseAmount: Int = 0
    var multiples: Int = 0
    var previousNicknameOffset: Int = -1
    var previousCardsCount: Int = 0
    var nextNicknameOffset: Int = -1
    var nextCardsCount: Int = 0
    var choosingLandlord: Boolean = false
    var landlord: Boolean = false
    var turnToPlay: Boolean = false

    var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
    var _done = false
    val _start_offset = _iprot.offset

    _iprot.readStructBegin()
    while (!_done) {
      val _field = _iprot.readFieldBegin()
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 =>
            _field.`type` match {
              case TType.I64 =>
    
                gameId = readGameIdValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 2 =>
            _field.`type` match {
              case TType.I32 =>
    
                gameType = readGameTypeValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'gameType' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 3 =>
            _field.`type` match {
              case TType.I32 =>
    
                deviceType = readDeviceTypeValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'deviceType' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 4 =>
            _field.`type` match {
              case TType.STRING =>
                cardsOffset = _iprot.offsetSkipString
    
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'cards' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 5 =>
            _field.`type` match {
              case TType.STRING =>
                landlordCardsOffset = _iprot.offsetSkipString
    
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'landlordCards' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 6 =>
            _field.`type` match {
              case TType.I32 =>
    
                baseAmount = readBaseAmountValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'baseAmount' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 7 =>
            _field.`type` match {
              case TType.I32 =>
    
                multiples = readMultiplesValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'multiples' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 8 =>
            _field.`type` match {
              case TType.STRING =>
                previousNicknameOffset = _iprot.offsetSkipString
    
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'previousNickname' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 9 =>
            _field.`type` match {
              case TType.I32 =>
    
                previousCardsCount = readPreviousCardsCountValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'previousCardsCount' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 10 =>
            _field.`type` match {
              case TType.STRING =>
                nextNicknameOffset = _iprot.offsetSkipString
    
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'nextNickname' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 11 =>
            _field.`type` match {
              case TType.I32 =>
    
                nextCardsCount = readNextCardsCountValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'nextCardsCount' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 12 =>
            _field.`type` match {
              case TType.BOOL =>
    
                choosingLandlord = readChoosingLandlordValue(_iprot)
              case _actualType =>
                val _expectedType = TType.BOOL
                throw new TProtocolException(
                  "Received wrong type for field 'choosingLandlord' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 13 =>
            _field.`type` match {
              case TType.BOOL =>
    
                landlord = readLandlordValue(_iprot)
              case _actualType =>
                val _expectedType = TType.BOOL
                throw new TProtocolException(
                  "Received wrong type for field 'landlord' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 14 =>
            _field.`type` match {
              case TType.BOOL =>
    
                turnToPlay = readTurnToPlayValue(_iprot)
              case _actualType =>
                val _expectedType = TType.BOOL
                throw new TProtocolException(
                  "Received wrong type for field 'turnToPlay' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case _ =>
            if (_passthroughFields == null)
              _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
            _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()

    new LazyImmutable(
      _iprot,
      _iprot.buffer,
      _start_offset,
      _iprot.offset,
      gameId,
      gameType,
      deviceType,
      cardsOffset,
      landlordCardsOffset,
      baseAmount,
      multiples,
      previousNicknameOffset,
      previousCardsCount,
      nextNicknameOffset,
      nextCardsCount,
      choosingLandlord,
      landlord,
      turnToPlay,
      if (_passthroughFields == null)
        NoPassthroughFields
      else
        _passthroughFields.result()
    )
  }

  override def decode(_iprot: TProtocol): GameTurnResponse =
    _iprot match {
      case i: LazyTProtocol => lazyDecode(i)
      case i => eagerDecode(i)
    }

  private[this] def eagerDecode(_iprot: TProtocol): GameTurnResponse = {
    var gameId: Long = 0L
    var gameType: Int = 0
    var deviceType: Int = 0
    var cards: String = ""
    var landlordCards: String = ""
    var baseAmount: Int = 0
    var multiples: Int = 0
    var previousNickname: String = ""
    var previousCardsCount: Int = 0
    var nextNickname: String = ""
    var nextCardsCount: Int = 0
    var choosingLandlord: Boolean = false
    var landlord: Boolean = false
    var turnToPlay: Boolean = false
    var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
    var _done = false

    _iprot.readStructBegin()
    while (!_done) {
      val _field = _iprot.readFieldBegin()
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 =>
            _field.`type` match {
              case TType.I64 =>
                gameId = readGameIdValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 2 =>
            _field.`type` match {
              case TType.I32 =>
                gameType = readGameTypeValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'gameType' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 3 =>
            _field.`type` match {
              case TType.I32 =>
                deviceType = readDeviceTypeValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'deviceType' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 4 =>
            _field.`type` match {
              case TType.STRING =>
                cards = readCardsValue(_iprot)
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'cards' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 5 =>
            _field.`type` match {
              case TType.STRING =>
                landlordCards = readLandlordCardsValue(_iprot)
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'landlordCards' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 6 =>
            _field.`type` match {
              case TType.I32 =>
                baseAmount = readBaseAmountValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'baseAmount' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 7 =>
            _field.`type` match {
              case TType.I32 =>
                multiples = readMultiplesValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'multiples' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 8 =>
            _field.`type` match {
              case TType.STRING =>
                previousNickname = readPreviousNicknameValue(_iprot)
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'previousNickname' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 9 =>
            _field.`type` match {
              case TType.I32 =>
                previousCardsCount = readPreviousCardsCountValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'previousCardsCount' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 10 =>
            _field.`type` match {
              case TType.STRING =>
                nextNickname = readNextNicknameValue(_iprot)
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'nextNickname' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 11 =>
            _field.`type` match {
              case TType.I32 =>
                nextCardsCount = readNextCardsCountValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'nextCardsCount' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 12 =>
            _field.`type` match {
              case TType.BOOL =>
                choosingLandlord = readChoosingLandlordValue(_iprot)
              case _actualType =>
                val _expectedType = TType.BOOL
                throw new TProtocolException(
                  "Received wrong type for field 'choosingLandlord' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 13 =>
            _field.`type` match {
              case TType.BOOL =>
                landlord = readLandlordValue(_iprot)
              case _actualType =>
                val _expectedType = TType.BOOL
                throw new TProtocolException(
                  "Received wrong type for field 'landlord' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 14 =>
            _field.`type` match {
              case TType.BOOL =>
                turnToPlay = readTurnToPlayValue(_iprot)
              case _actualType =>
                val _expectedType = TType.BOOL
                throw new TProtocolException(
                  "Received wrong type for field 'turnToPlay' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case _ =>
            if (_passthroughFields == null)
              _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
            _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()

    new Immutable(
      gameId,
      gameType,
      deviceType,
      cards,
      landlordCards,
      baseAmount,
      multiples,
      previousNickname,
      previousCardsCount,
      nextNickname,
      nextCardsCount,
      choosingLandlord,
      landlord,
      turnToPlay,
      if (_passthroughFields == null)
        NoPassthroughFields
      else
        _passthroughFields.result()
    )
  }

  def apply(
    gameId: Long = 0L,
    gameType: Int = 0,
    deviceType: Int = 0,
    cards: String = "",
    landlordCards: String = "",
    baseAmount: Int = 0,
    multiples: Int = 0,
    previousNickname: String = "",
    previousCardsCount: Int = 0,
    nextNickname: String = "",
    nextCardsCount: Int = 0,
    choosingLandlord: Boolean = false,
    landlord: Boolean = false,
    turnToPlay: Boolean = false
  ): GameTurnResponse =
    new Immutable(
      gameId,
      gameType,
      deviceType,
      cards,
      landlordCards,
      baseAmount,
      multiples,
      previousNickname,
      previousCardsCount,
      nextNickname,
      nextCardsCount,
      choosingLandlord,
      landlord,
      turnToPlay
    )

  def unapply(_item: GameTurnResponse): _root_.scala.Option[scala.Product14[Long, Int, Int, String, String, Int, Int, String, Int, String, Int, Boolean, Boolean, Boolean]] = _root_.scala.Some(_item)


  @inline private def readGameIdValue(_iprot: TProtocol): Long = {
    _iprot.readI64()
  }

  @inline private def writeGameIdField(gameId_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(GameIdField)
    writeGameIdValue(gameId_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeGameIdValue(gameId_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeI64(gameId_item)
  }

  @inline private def readGameTypeValue(_iprot: TProtocol): Int = {
    _iprot.readI32()
  }

  @inline private def writeGameTypeField(gameType_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(GameTypeField)
    writeGameTypeValue(gameType_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeGameTypeValue(gameType_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeI32(gameType_item)
  }

  @inline private def readDeviceTypeValue(_iprot: TProtocol): Int = {
    _iprot.readI32()
  }

  @inline private def writeDeviceTypeField(deviceType_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(DeviceTypeField)
    writeDeviceTypeValue(deviceType_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeDeviceTypeValue(deviceType_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeI32(deviceType_item)
  }

  @inline private def readCardsValue(_iprot: TProtocol): String = {
    _iprot.readString()
  }

  @inline private def writeCardsField(cards_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(CardsField)
    writeCardsValue(cards_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeCardsValue(cards_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeString(cards_item)
  }

  @inline private def readLandlordCardsValue(_iprot: TProtocol): String = {
    _iprot.readString()
  }

  @inline private def writeLandlordCardsField(landlordCards_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(LandlordCardsField)
    writeLandlordCardsValue(landlordCards_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeLandlordCardsValue(landlordCards_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeString(landlordCards_item)
  }

  @inline private def readBaseAmountValue(_iprot: TProtocol): Int = {
    _iprot.readI32()
  }

  @inline private def writeBaseAmountField(baseAmount_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(BaseAmountField)
    writeBaseAmountValue(baseAmount_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeBaseAmountValue(baseAmount_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeI32(baseAmount_item)
  }

  @inline private def readMultiplesValue(_iprot: TProtocol): Int = {
    _iprot.readI32()
  }

  @inline private def writeMultiplesField(multiples_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(MultiplesField)
    writeMultiplesValue(multiples_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeMultiplesValue(multiples_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeI32(multiples_item)
  }

  @inline private def readPreviousNicknameValue(_iprot: TProtocol): String = {
    _iprot.readString()
  }

  @inline private def writePreviousNicknameField(previousNickname_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(PreviousNicknameField)
    writePreviousNicknameValue(previousNickname_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writePreviousNicknameValue(previousNickname_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeString(previousNickname_item)
  }

  @inline private def readPreviousCardsCountValue(_iprot: TProtocol): Int = {
    _iprot.readI32()
  }

  @inline private def writePreviousCardsCountField(previousCardsCount_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(PreviousCardsCountField)
    writePreviousCardsCountValue(previousCardsCount_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writePreviousCardsCountValue(previousCardsCount_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeI32(previousCardsCount_item)
  }

  @inline private def readNextNicknameValue(_iprot: TProtocol): String = {
    _iprot.readString()
  }

  @inline private def writeNextNicknameField(nextNickname_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(NextNicknameField)
    writeNextNicknameValue(nextNickname_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeNextNicknameValue(nextNickname_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeString(nextNickname_item)
  }

  @inline private def readNextCardsCountValue(_iprot: TProtocol): Int = {
    _iprot.readI32()
  }

  @inline private def writeNextCardsCountField(nextCardsCount_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(NextCardsCountField)
    writeNextCardsCountValue(nextCardsCount_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeNextCardsCountValue(nextCardsCount_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeI32(nextCardsCount_item)
  }

  @inline private def readChoosingLandlordValue(_iprot: TProtocol): Boolean = {
    _iprot.readBool()
  }

  @inline private def writeChoosingLandlordField(choosingLandlord_item: Boolean, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(ChoosingLandlordField)
    writeChoosingLandlordValue(choosingLandlord_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeChoosingLandlordValue(choosingLandlord_item: Boolean, _oprot: TProtocol): Unit = {
    _oprot.writeBool(choosingLandlord_item)
  }

  @inline private def readLandlordValue(_iprot: TProtocol): Boolean = {
    _iprot.readBool()
  }

  @inline private def writeLandlordField(landlord_item: Boolean, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(LandlordField)
    writeLandlordValue(landlord_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeLandlordValue(landlord_item: Boolean, _oprot: TProtocol): Unit = {
    _oprot.writeBool(landlord_item)
  }

  @inline private def readTurnToPlayValue(_iprot: TProtocol): Boolean = {
    _iprot.readBool()
  }

  @inline private def writeTurnToPlayField(turnToPlay_item: Boolean, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(TurnToPlayField)
    writeTurnToPlayValue(turnToPlay_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeTurnToPlayValue(turnToPlay_item: Boolean, _oprot: TProtocol): Unit = {
    _oprot.writeBool(turnToPlay_item)
  }


  object Immutable extends ThriftStructCodec3[GameTurnResponse] {
    override def encode(_item: GameTurnResponse, _oproto: TProtocol): Unit = { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): GameTurnResponse = GameTurnResponse.decode(_iprot)
    override lazy val metaData: ThriftStructMetaData[GameTurnResponse] = GameTurnResponse.metaData
  }

  /**
   * The default read-only implementation of GameTurnResponse.  You typically should not need to
   * directly reference this class; instead, use the GameTurnResponse.apply method to construct
   * new instances.
   */
  class Immutable(
      val gameId: Long,
      val gameType: Int,
      val deviceType: Int,
      val cards: String,
      val landlordCards: String,
      val baseAmount: Int,
      val multiples: Int,
      val previousNickname: String,
      val previousCardsCount: Int,
      val nextNickname: String,
      val nextCardsCount: Int,
      val choosingLandlord: Boolean,
      val landlord: Boolean,
      val turnToPlay: Boolean,
      override val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends GameTurnResponse {
    def this(
      gameId: Long = 0L,
      gameType: Int = 0,
      deviceType: Int = 0,
      cards: String = "",
      landlordCards: String = "",
      baseAmount: Int = 0,
      multiples: Int = 0,
      previousNickname: String = "",
      previousCardsCount: Int = 0,
      nextNickname: String = "",
      nextCardsCount: Int = 0,
      choosingLandlord: Boolean = false,
      landlord: Boolean = false,
      turnToPlay: Boolean = false
    ) = this(
      gameId,
      gameType,
      deviceType,
      cards,
      landlordCards,
      baseAmount,
      multiples,
      previousNickname,
      previousCardsCount,
      nextNickname,
      nextCardsCount,
      choosingLandlord,
      landlord,
      turnToPlay,
      Map.empty
    )
  }

  /**
   * This is another Immutable, this however keeps strings as lazy values that are lazily decoded from the backing
   * array byte on read.
   */
  private[this] class LazyImmutable(
      _proto: LazyTProtocol,
      _buf: Array[Byte],
      _start_offset: Int,
      _end_offset: Int,
      val gameId: Long,
      val gameType: Int,
      val deviceType: Int,
      cardsOffset: Int,
      landlordCardsOffset: Int,
      val baseAmount: Int,
      val multiples: Int,
      previousNicknameOffset: Int,
      val previousCardsCount: Int,
      nextNicknameOffset: Int,
      val nextCardsCount: Int,
      val choosingLandlord: Boolean,
      val landlord: Boolean,
      val turnToPlay: Boolean,
      override val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends GameTurnResponse {

    override def write(_oprot: TProtocol): Unit = {
      _oprot match {
        case i: LazyTProtocol => i.writeRaw(_buf, _start_offset, _end_offset - _start_offset)
        case _ => super.write(_oprot)
      }
    }

    lazy val cards: String =
      if (cardsOffset == -1)
        ""
      else {
        _proto.decodeString(_buf, cardsOffset)
      }
    lazy val landlordCards: String =
      if (landlordCardsOffset == -1)
        ""
      else {
        _proto.decodeString(_buf, landlordCardsOffset)
      }
    lazy val previousNickname: String =
      if (previousNicknameOffset == -1)
        ""
      else {
        _proto.decodeString(_buf, previousNicknameOffset)
      }
    lazy val nextNickname: String =
      if (nextNicknameOffset == -1)
        ""
      else {
        _proto.decodeString(_buf, nextNicknameOffset)
      }

    /**
     * Override the super hash code to make it a lazy val rather than def.
     *
     * Calculating the hash code can be expensive, caching it where possible
     * can provide significant performance wins. (Key in a hash map for instance)
     * Usually not safe since the normal constructor will accept a mutable map or
     * set as an arg
     * Here however we control how the class is generated from serialized data.
     * With the class private and the contract that we throw away our mutable references
     * having the hash code lazy here is safe.
     */
    override lazy val hashCode = super.hashCode
  }

  /**
   * This Proxy trait allows you to extend the GameTurnResponse trait with additional state or
   * behavior and implement the read-only methods from GameTurnResponse using an underlying
   * instance.
   */
  trait Proxy extends GameTurnResponse {
    protected def _underlying_GameTurnResponse: GameTurnResponse
    override def gameId: Long = _underlying_GameTurnResponse.gameId
    override def gameType: Int = _underlying_GameTurnResponse.gameType
    override def deviceType: Int = _underlying_GameTurnResponse.deviceType
    override def cards: String = _underlying_GameTurnResponse.cards
    override def landlordCards: String = _underlying_GameTurnResponse.landlordCards
    override def baseAmount: Int = _underlying_GameTurnResponse.baseAmount
    override def multiples: Int = _underlying_GameTurnResponse.multiples
    override def previousNickname: String = _underlying_GameTurnResponse.previousNickname
    override def previousCardsCount: Int = _underlying_GameTurnResponse.previousCardsCount
    override def nextNickname: String = _underlying_GameTurnResponse.nextNickname
    override def nextCardsCount: Int = _underlying_GameTurnResponse.nextCardsCount
    override def choosingLandlord: Boolean = _underlying_GameTurnResponse.choosingLandlord
    override def landlord: Boolean = _underlying_GameTurnResponse.landlord
    override def turnToPlay: Boolean = _underlying_GameTurnResponse.turnToPlay
    override def _passthroughFields = _underlying_GameTurnResponse._passthroughFields
  }
}

trait GameTurnResponse
  extends ThriftStruct
  with scala.Product14[Long, Int, Int, String, String, Int, Int, String, Int, String, Int, Boolean, Boolean, Boolean]
  with java.io.Serializable
{
  import GameTurnResponse._

  def gameId: Long
  def gameType: Int
  def deviceType: Int
  def cards: String
  def landlordCards: String
  def baseAmount: Int
  def multiples: Int
  def previousNickname: String
  def previousCardsCount: Int
  def nextNickname: String
  def nextCardsCount: Int
  def choosingLandlord: Boolean
  def landlord: Boolean
  def turnToPlay: Boolean

  def _passthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty

  def _1 = gameId
  def _2 = gameType
  def _3 = deviceType
  def _4 = cards
  def _5 = landlordCards
  def _6 = baseAmount
  def _7 = multiples
  def _8 = previousNickname
  def _9 = previousCardsCount
  def _10 = nextNickname
  def _11 = nextCardsCount
  def _12 = choosingLandlord
  def _13 = landlord
  def _14 = turnToPlay


  /**
   * Gets a field value encoded as a binary blob using TCompactProtocol.  If the specified field
   * is present in the passthrough map, that value is returned.  Otherwise, if the specified field
   * is known and not optional and set to None, then the field is serialized and returned.
   */
  def getFieldBlob(_fieldId: Short): _root_.scala.Option[TFieldBlob] = {
    lazy val _buff = new TMemoryBuffer(32)
    lazy val _oprot = new TCompactProtocol(_buff)
    _passthroughFields.get(_fieldId) match {
      case blob: _root_.scala.Some[TFieldBlob] => blob
      case _root_.scala.None => {
        val _fieldOpt: _root_.scala.Option[TField] =
          _fieldId match {
            case 1 =>
              if (true) {
                writeGameIdValue(gameId, _oprot)
                _root_.scala.Some(GameTurnResponse.GameIdField)
              } else {
                _root_.scala.None
              }
            case 2 =>
              if (true) {
                writeGameTypeValue(gameType, _oprot)
                _root_.scala.Some(GameTurnResponse.GameTypeField)
              } else {
                _root_.scala.None
              }
            case 3 =>
              if (true) {
                writeDeviceTypeValue(deviceType, _oprot)
                _root_.scala.Some(GameTurnResponse.DeviceTypeField)
              } else {
                _root_.scala.None
              }
            case 4 =>
              if (cards ne null) {
                writeCardsValue(cards, _oprot)
                _root_.scala.Some(GameTurnResponse.CardsField)
              } else {
                _root_.scala.None
              }
            case 5 =>
              if (landlordCards ne null) {
                writeLandlordCardsValue(landlordCards, _oprot)
                _root_.scala.Some(GameTurnResponse.LandlordCardsField)
              } else {
                _root_.scala.None
              }
            case 6 =>
              if (true) {
                writeBaseAmountValue(baseAmount, _oprot)
                _root_.scala.Some(GameTurnResponse.BaseAmountField)
              } else {
                _root_.scala.None
              }
            case 7 =>
              if (true) {
                writeMultiplesValue(multiples, _oprot)
                _root_.scala.Some(GameTurnResponse.MultiplesField)
              } else {
                _root_.scala.None
              }
            case 8 =>
              if (previousNickname ne null) {
                writePreviousNicknameValue(previousNickname, _oprot)
                _root_.scala.Some(GameTurnResponse.PreviousNicknameField)
              } else {
                _root_.scala.None
              }
            case 9 =>
              if (true) {
                writePreviousCardsCountValue(previousCardsCount, _oprot)
                _root_.scala.Some(GameTurnResponse.PreviousCardsCountField)
              } else {
                _root_.scala.None
              }
            case 10 =>
              if (nextNickname ne null) {
                writeNextNicknameValue(nextNickname, _oprot)
                _root_.scala.Some(GameTurnResponse.NextNicknameField)
              } else {
                _root_.scala.None
              }
            case 11 =>
              if (true) {
                writeNextCardsCountValue(nextCardsCount, _oprot)
                _root_.scala.Some(GameTurnResponse.NextCardsCountField)
              } else {
                _root_.scala.None
              }
            case 12 =>
              if (true) {
                writeChoosingLandlordValue(choosingLandlord, _oprot)
                _root_.scala.Some(GameTurnResponse.ChoosingLandlordField)
              } else {
                _root_.scala.None
              }
            case 13 =>
              if (true) {
                writeLandlordValue(landlord, _oprot)
                _root_.scala.Some(GameTurnResponse.LandlordField)
              } else {
                _root_.scala.None
              }
            case 14 =>
              if (true) {
                writeTurnToPlayValue(turnToPlay, _oprot)
                _root_.scala.Some(GameTurnResponse.TurnToPlayField)
              } else {
                _root_.scala.None
              }
            case _ => _root_.scala.None
          }
        _fieldOpt match {
          case _root_.scala.Some(_field) =>
            val _data = Arrays.copyOfRange(_buff.getArray, 0, _buff.length)
            _root_.scala.Some(TFieldBlob(_field, _data))
          case _root_.scala.None =>
            _root_.scala.None
        }
      }
    }
  }

  /**
   * Collects TCompactProtocol-encoded field values according to `getFieldBlob` into a map.
   */
  def getFieldBlobs(ids: TraversableOnce[Short]): immutable$Map[Short, TFieldBlob] =
    (ids flatMap { id => getFieldBlob(id) map { id -> _ } }).toMap

  /**
   * Sets a field using a TCompactProtocol-encoded binary blob.  If the field is a known
   * field, the blob is decoded and the field is set to the decoded value.  If the field
   * is unknown and passthrough fields are enabled, then the blob will be stored in
   * _passthroughFields.
   */
  def setField(_blob: TFieldBlob): GameTurnResponse = {
    var gameId: Long = this.gameId
    var gameType: Int = this.gameType
    var deviceType: Int = this.deviceType
    var cards: String = this.cards
    var landlordCards: String = this.landlordCards
    var baseAmount: Int = this.baseAmount
    var multiples: Int = this.multiples
    var previousNickname: String = this.previousNickname
    var previousCardsCount: Int = this.previousCardsCount
    var nextNickname: String = this.nextNickname
    var nextCardsCount: Int = this.nextCardsCount
    var choosingLandlord: Boolean = this.choosingLandlord
    var landlord: Boolean = this.landlord
    var turnToPlay: Boolean = this.turnToPlay
    var _passthroughFields = this._passthroughFields
    _blob.id match {
      case 1 =>
        gameId = readGameIdValue(_blob.read)
      case 2 =>
        gameType = readGameTypeValue(_blob.read)
      case 3 =>
        deviceType = readDeviceTypeValue(_blob.read)
      case 4 =>
        cards = readCardsValue(_blob.read)
      case 5 =>
        landlordCards = readLandlordCardsValue(_blob.read)
      case 6 =>
        baseAmount = readBaseAmountValue(_blob.read)
      case 7 =>
        multiples = readMultiplesValue(_blob.read)
      case 8 =>
        previousNickname = readPreviousNicknameValue(_blob.read)
      case 9 =>
        previousCardsCount = readPreviousCardsCountValue(_blob.read)
      case 10 =>
        nextNickname = readNextNicknameValue(_blob.read)
      case 11 =>
        nextCardsCount = readNextCardsCountValue(_blob.read)
      case 12 =>
        choosingLandlord = readChoosingLandlordValue(_blob.read)
      case 13 =>
        landlord = readLandlordValue(_blob.read)
      case 14 =>
        turnToPlay = readTurnToPlayValue(_blob.read)
      case _ => _passthroughFields += (_blob.id -> _blob)
    }
    new Immutable(
      gameId,
      gameType,
      deviceType,
      cards,
      landlordCards,
      baseAmount,
      multiples,
      previousNickname,
      previousCardsCount,
      nextNickname,
      nextCardsCount,
      choosingLandlord,
      landlord,
      turnToPlay,
      _passthroughFields
    )
  }

  /**
   * If the specified field is optional, it is set to None.  Otherwise, if the field is
   * known, it is reverted to its default value; if the field is unknown, it is removed
   * from the passthroughFields map, if present.
   */
  def unsetField(_fieldId: Short): GameTurnResponse = {
    var gameId: Long = this.gameId
    var gameType: Int = this.gameType
    var deviceType: Int = this.deviceType
    var cards: String = this.cards
    var landlordCards: String = this.landlordCards
    var baseAmount: Int = this.baseAmount
    var multiples: Int = this.multiples
    var previousNickname: String = this.previousNickname
    var previousCardsCount: Int = this.previousCardsCount
    var nextNickname: String = this.nextNickname
    var nextCardsCount: Int = this.nextCardsCount
    var choosingLandlord: Boolean = this.choosingLandlord
    var landlord: Boolean = this.landlord
    var turnToPlay: Boolean = this.turnToPlay

    _fieldId match {
      case 1 =>
        gameId = 0L
      case 2 =>
        gameType = 0
      case 3 =>
        deviceType = 0
      case 4 =>
        cards = ""
      case 5 =>
        landlordCards = ""
      case 6 =>
        baseAmount = 0
      case 7 =>
        multiples = 0
      case 8 =>
        previousNickname = ""
      case 9 =>
        previousCardsCount = 0
      case 10 =>
        nextNickname = ""
      case 11 =>
        nextCardsCount = 0
      case 12 =>
        choosingLandlord = false
      case 13 =>
        landlord = false
      case 14 =>
        turnToPlay = false
      case _ =>
    }
    new Immutable(
      gameId,
      gameType,
      deviceType,
      cards,
      landlordCards,
      baseAmount,
      multiples,
      previousNickname,
      previousCardsCount,
      nextNickname,
      nextCardsCount,
      choosingLandlord,
      landlord,
      turnToPlay,
      _passthroughFields - _fieldId
    )
  }

  /**
   * If the specified field is optional, it is set to None.  Otherwise, if the field is
   * known, it is reverted to its default value; if the field is unknown, it is removed
   * from the passthroughFields map, if present.
   */
  def unsetGameId: GameTurnResponse = unsetField(1)

  def unsetGameType: GameTurnResponse = unsetField(2)

  def unsetDeviceType: GameTurnResponse = unsetField(3)

  def unsetCards: GameTurnResponse = unsetField(4)

  def unsetLandlordCards: GameTurnResponse = unsetField(5)

  def unsetBaseAmount: GameTurnResponse = unsetField(6)

  def unsetMultiples: GameTurnResponse = unsetField(7)

  def unsetPreviousNickname: GameTurnResponse = unsetField(8)

  def unsetPreviousCardsCount: GameTurnResponse = unsetField(9)

  def unsetNextNickname: GameTurnResponse = unsetField(10)

  def unsetNextCardsCount: GameTurnResponse = unsetField(11)

  def unsetChoosingLandlord: GameTurnResponse = unsetField(12)

  def unsetLandlord: GameTurnResponse = unsetField(13)

  def unsetTurnToPlay: GameTurnResponse = unsetField(14)


  override def write(_oprot: TProtocol): Unit = {
    GameTurnResponse.validate(this)
    _oprot.writeStructBegin(Struct)
    writeGameIdField(gameId, _oprot)
    writeGameTypeField(gameType, _oprot)
    writeDeviceTypeField(deviceType, _oprot)
    if (cards ne null) writeCardsField(cards, _oprot)
    if (landlordCards ne null) writeLandlordCardsField(landlordCards, _oprot)
    writeBaseAmountField(baseAmount, _oprot)
    writeMultiplesField(multiples, _oprot)
    if (previousNickname ne null) writePreviousNicknameField(previousNickname, _oprot)
    writePreviousCardsCountField(previousCardsCount, _oprot)
    if (nextNickname ne null) writeNextNicknameField(nextNickname, _oprot)
    writeNextCardsCountField(nextCardsCount, _oprot)
    writeChoosingLandlordField(choosingLandlord, _oprot)
    writeLandlordField(landlord, _oprot)
    writeTurnToPlayField(turnToPlay, _oprot)
    if (_passthroughFields.nonEmpty) {
      _passthroughFields.values.foreach { _.write(_oprot) }
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def copy(
    gameId: Long = this.gameId,
    gameType: Int = this.gameType,
    deviceType: Int = this.deviceType,
    cards: String = this.cards,
    landlordCards: String = this.landlordCards,
    baseAmount: Int = this.baseAmount,
    multiples: Int = this.multiples,
    previousNickname: String = this.previousNickname,
    previousCardsCount: Int = this.previousCardsCount,
    nextNickname: String = this.nextNickname,
    nextCardsCount: Int = this.nextCardsCount,
    choosingLandlord: Boolean = this.choosingLandlord,
    landlord: Boolean = this.landlord,
    turnToPlay: Boolean = this.turnToPlay,
    _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
  ): GameTurnResponse =
    new Immutable(
      gameId,
      gameType,
      deviceType,
      cards,
      landlordCards,
      baseAmount,
      multiples,
      previousNickname,
      previousCardsCount,
      nextNickname,
      nextCardsCount,
      choosingLandlord,
      landlord,
      turnToPlay,
      _passthroughFields
    )

  override def canEqual(other: Any): Boolean = other.isInstanceOf[GameTurnResponse]

  override def equals(other: Any): Boolean =
    canEqual(other) &&
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
      _passthroughFields == other.asInstanceOf[GameTurnResponse]._passthroughFields

  override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)

  override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)


  override def productArity: Int = 14

  override def productElement(n: Int): Any = n match {
    case 0 => this.gameId
    case 1 => this.gameType
    case 2 => this.deviceType
    case 3 => this.cards
    case 4 => this.landlordCards
    case 5 => this.baseAmount
    case 6 => this.multiples
    case 7 => this.previousNickname
    case 8 => this.previousCardsCount
    case 9 => this.nextNickname
    case 10 => this.nextCardsCount
    case 11 => this.choosingLandlord
    case 12 => this.landlord
    case 13 => this.turnToPlay
    case _ => throw new IndexOutOfBoundsException(n.toString)
  }

  override def productPrefix: String = "GameTurnResponse"
}