/**
 * Generated by Scrooge
 *   version: 4.5.0
 *   rev: 014664de600267b36809bbc85225e26aec286216
 *   built at: 20160203-205352
 */
package com.jxjxgo.game.rpc.domain

import com.twitter.scrooge.{
  LazyTProtocol,
  TFieldBlob, ThriftException, ThriftStruct, ThriftStructCodec3, ThriftStructFieldInfo,
  ThriftStructMetaData, ThriftUtil}
import org.apache.thrift.protocol._
import org.apache.thrift.transport.{TMemoryBuffer, TTransport}
import java.nio.ByteBuffer
import java.util.Arrays
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.Builder
import scala.collection.mutable.{
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}


object GameTurnResponse extends ThriftStructCodec3[GameTurnResponse] {
  private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
  val Struct = new TStruct("GameTurnResponse")
  val GameIdField = new TField("gameId", TType.I64, 1)
  val GameIdFieldManifest = implicitly[Manifest[Long]]
  val GameTypeField = new TField("gameType", TType.STRING, 2)
  val GameTypeFieldManifest = implicitly[Manifest[String]]
  val CardsField = new TField("cards", TType.STRING, 3)
  val CardsFieldManifest = implicitly[Manifest[String]]
  val BaseAmountField = new TField("baseAmount", TType.I32, 4)
  val BaseAmountFieldManifest = implicitly[Manifest[Int]]
  val MultiplesField = new TField("multiples", TType.I32, 5)
  val MultiplesFieldManifest = implicitly[Manifest[Int]]
  val PreviousUsernameField = new TField("previousUsername", TType.STRING, 6)
  val PreviousUsernameFieldManifest = implicitly[Manifest[String]]
  val PreviousCardsCountField = new TField("previousCardsCount", TType.I32, 7)
  val PreviousCardsCountFieldManifest = implicitly[Manifest[Int]]
  val NextUsernameField = new TField("nextUsername", TType.STRING, 8)
  val NextUsernameFieldManifest = implicitly[Manifest[String]]
  val NextCardsCountField = new TField("nextCardsCount", TType.I32, 9)
  val NextCardsCountFieldManifest = implicitly[Manifest[Int]]
  val IsChoosingLandlordField = new TField("isChoosingLandlord", TType.BOOL, 10)
  val IsChoosingLandlordFieldManifest = implicitly[Manifest[Boolean]]
  val IsLandlordField = new TField("isLandlord", TType.BOOL, 11)
  val IsLandlordFieldManifest = implicitly[Manifest[Boolean]]
  val TurnToPlayField = new TField("turnToPlay", TType.BOOL, 12)
  val TurnToPlayFieldManifest = implicitly[Manifest[Boolean]]

  /**
   * Field information in declaration order.
   */
  lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    new ThriftStructFieldInfo(
      GameIdField,
      false,
      false,
      GameIdFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      GameTypeField,
      false,
      false,
      GameTypeFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      CardsField,
      false,
      false,
      CardsFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      BaseAmountField,
      false,
      false,
      BaseAmountFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      MultiplesField,
      false,
      false,
      MultiplesFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      PreviousUsernameField,
      false,
      false,
      PreviousUsernameFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      PreviousCardsCountField,
      false,
      false,
      PreviousCardsCountFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      NextUsernameField,
      false,
      false,
      NextUsernameFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      NextCardsCountField,
      false,
      false,
      NextCardsCountFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      IsChoosingLandlordField,
      false,
      false,
      IsChoosingLandlordFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      IsLandlordField,
      false,
      false,
      IsLandlordFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    ),
    new ThriftStructFieldInfo(
      TurnToPlayField,
      false,
      false,
      TurnToPlayFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String]
    )
  )

  lazy val structAnnotations: immutable$Map[String, String] =
    immutable$Map.empty[String, String]

  /**
   * Checks that all required fields are non-null.
   */
  def validate(_item: GameTurnResponse): Unit = {
  }

  def withoutPassthroughFields(original: GameTurnResponse): GameTurnResponse =
    new Immutable(
      gameId =
        {
          val field = original.gameId
          field
        },
      gameType =
        {
          val field = original.gameType
          field
        },
      cards =
        {
          val field = original.cards
          field
        },
      baseAmount =
        {
          val field = original.baseAmount
          field
        },
      multiples =
        {
          val field = original.multiples
          field
        },
      previousUsername =
        {
          val field = original.previousUsername
          field
        },
      previousCardsCount =
        {
          val field = original.previousCardsCount
          field
        },
      nextUsername =
        {
          val field = original.nextUsername
          field
        },
      nextCardsCount =
        {
          val field = original.nextCardsCount
          field
        },
      isChoosingLandlord =
        {
          val field = original.isChoosingLandlord
          field
        },
      isLandlord =
        {
          val field = original.isLandlord
          field
        },
      turnToPlay =
        {
          val field = original.turnToPlay
          field
        }
    )

  override def encode(_item: GameTurnResponse, _oproto: TProtocol): Unit = {
    _item.write(_oproto)
  }

  private[this] def lazyDecode(_iprot: LazyTProtocol): GameTurnResponse = {

    var gameId: Long = 0L
    var gameTypeOffset: Int = -1
    var cardsOffset: Int = -1
    var baseAmount: Int = 0
    var multiples: Int = 0
    var previousUsernameOffset: Int = -1
    var previousCardsCount: Int = 0
    var nextUsernameOffset: Int = -1
    var nextCardsCount: Int = 0
    var isChoosingLandlord: Boolean = false
    var isLandlord: Boolean = false
    var turnToPlay: Boolean = false

    var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
    var _done = false
    val _start_offset = _iprot.offset

    _iprot.readStructBegin()
    while (!_done) {
      val _field = _iprot.readFieldBegin()
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 =>
            _field.`type` match {
              case TType.I64 =>
    
                gameId = readGameIdValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 2 =>
            _field.`type` match {
              case TType.STRING =>
                gameTypeOffset = _iprot.offsetSkipString
    
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'gameType' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 3 =>
            _field.`type` match {
              case TType.STRING =>
                cardsOffset = _iprot.offsetSkipString
    
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'cards' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 4 =>
            _field.`type` match {
              case TType.I32 =>
    
                baseAmount = readBaseAmountValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'baseAmount' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 5 =>
            _field.`type` match {
              case TType.I32 =>
    
                multiples = readMultiplesValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'multiples' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 6 =>
            _field.`type` match {
              case TType.STRING =>
                previousUsernameOffset = _iprot.offsetSkipString
    
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'previousUsername' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 7 =>
            _field.`type` match {
              case TType.I32 =>
    
                previousCardsCount = readPreviousCardsCountValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'previousCardsCount' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 8 =>
            _field.`type` match {
              case TType.STRING =>
                nextUsernameOffset = _iprot.offsetSkipString
    
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'nextUsername' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 9 =>
            _field.`type` match {
              case TType.I32 =>
    
                nextCardsCount = readNextCardsCountValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'nextCardsCount' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 10 =>
            _field.`type` match {
              case TType.BOOL =>
    
                isChoosingLandlord = readIsChoosingLandlordValue(_iprot)
              case _actualType =>
                val _expectedType = TType.BOOL
                throw new TProtocolException(
                  "Received wrong type for field 'isChoosingLandlord' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 11 =>
            _field.`type` match {
              case TType.BOOL =>
    
                isLandlord = readIsLandlordValue(_iprot)
              case _actualType =>
                val _expectedType = TType.BOOL
                throw new TProtocolException(
                  "Received wrong type for field 'isLandlord' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 12 =>
            _field.`type` match {
              case TType.BOOL =>
    
                turnToPlay = readTurnToPlayValue(_iprot)
              case _actualType =>
                val _expectedType = TType.BOOL
                throw new TProtocolException(
                  "Received wrong type for field 'turnToPlay' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case _ =>
            if (_passthroughFields == null)
              _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
            _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()

    new LazyImmutable(
      _iprot,
      _iprot.buffer,
      _start_offset,
      _iprot.offset,
      gameId,
      gameTypeOffset,
      cardsOffset,
      baseAmount,
      multiples,
      previousUsernameOffset,
      previousCardsCount,
      nextUsernameOffset,
      nextCardsCount,
      isChoosingLandlord,
      isLandlord,
      turnToPlay,
      if (_passthroughFields == null)
        NoPassthroughFields
      else
        _passthroughFields.result()
    )
  }

  override def decode(_iprot: TProtocol): GameTurnResponse =
    _iprot match {
      case i: LazyTProtocol => lazyDecode(i)
      case i => eagerDecode(i)
    }

  private[this] def eagerDecode(_iprot: TProtocol): GameTurnResponse = {
    var gameId: Long = 0L
    var gameType: String = ""
    var cards: String = ""
    var baseAmount: Int = 0
    var multiples: Int = 0
    var previousUsername: String = null
    var previousCardsCount: Int = 0
    var nextUsername: String = null
    var nextCardsCount: Int = 0
    var isChoosingLandlord: Boolean = false
    var isLandlord: Boolean = false
    var turnToPlay: Boolean = false
    var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
    var _done = false

    _iprot.readStructBegin()
    while (!_done) {
      val _field = _iprot.readFieldBegin()
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 =>
            _field.`type` match {
              case TType.I64 =>
                gameId = readGameIdValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 2 =>
            _field.`type` match {
              case TType.STRING =>
                gameType = readGameTypeValue(_iprot)
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'gameType' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 3 =>
            _field.`type` match {
              case TType.STRING =>
                cards = readCardsValue(_iprot)
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'cards' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 4 =>
            _field.`type` match {
              case TType.I32 =>
                baseAmount = readBaseAmountValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'baseAmount' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 5 =>
            _field.`type` match {
              case TType.I32 =>
                multiples = readMultiplesValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'multiples' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 6 =>
            _field.`type` match {
              case TType.STRING =>
                previousUsername = readPreviousUsernameValue(_iprot)
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'previousUsername' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 7 =>
            _field.`type` match {
              case TType.I32 =>
                previousCardsCount = readPreviousCardsCountValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'previousCardsCount' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 8 =>
            _field.`type` match {
              case TType.STRING =>
                nextUsername = readNextUsernameValue(_iprot)
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'nextUsername' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 9 =>
            _field.`type` match {
              case TType.I32 =>
                nextCardsCount = readNextCardsCountValue(_iprot)
              case _actualType =>
                val _expectedType = TType.I32
                throw new TProtocolException(
                  "Received wrong type for field 'nextCardsCount' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 10 =>
            _field.`type` match {
              case TType.BOOL =>
                isChoosingLandlord = readIsChoosingLandlordValue(_iprot)
              case _actualType =>
                val _expectedType = TType.BOOL
                throw new TProtocolException(
                  "Received wrong type for field 'isChoosingLandlord' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 11 =>
            _field.`type` match {
              case TType.BOOL =>
                isLandlord = readIsLandlordValue(_iprot)
              case _actualType =>
                val _expectedType = TType.BOOL
                throw new TProtocolException(
                  "Received wrong type for field 'isLandlord' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 12 =>
            _field.`type` match {
              case TType.BOOL =>
                turnToPlay = readTurnToPlayValue(_iprot)
              case _actualType =>
                val _expectedType = TType.BOOL
                throw new TProtocolException(
                  "Received wrong type for field 'turnToPlay' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case _ =>
            if (_passthroughFields == null)
              _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
            _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()

    new Immutable(
      gameId,
      gameType,
      cards,
      baseAmount,
      multiples,
      previousUsername,
      previousCardsCount,
      nextUsername,
      nextCardsCount,
      isChoosingLandlord,
      isLandlord,
      turnToPlay,
      if (_passthroughFields == null)
        NoPassthroughFields
      else
        _passthroughFields.result()
    )
  }

  def apply(
    gameId: Long = 0L,
    gameType: String = "",
    cards: String = "",
    baseAmount: Int = 0,
    multiples: Int = 0,
    previousUsername: String,
    previousCardsCount: Int = 0,
    nextUsername: String,
    nextCardsCount: Int = 0,
    isChoosingLandlord: Boolean = false,
    isLandlord: Boolean = false,
    turnToPlay: Boolean = false
  ): GameTurnResponse =
    new Immutable(
      gameId,
      gameType,
      cards,
      baseAmount,
      multiples,
      previousUsername,
      previousCardsCount,
      nextUsername,
      nextCardsCount,
      isChoosingLandlord,
      isLandlord,
      turnToPlay
    )

  def unapply(_item: GameTurnResponse): _root_.scala.Option[scala.Product12[Long, String, String, Int, Int, String, Int, String, Int, Boolean, Boolean, Boolean]] = _root_.scala.Some(_item)


  @inline private def readGameIdValue(_iprot: TProtocol): Long = {
    _iprot.readI64()
  }

  @inline private def writeGameIdField(gameId_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(GameIdField)
    writeGameIdValue(gameId_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeGameIdValue(gameId_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeI64(gameId_item)
  }

  @inline private def readGameTypeValue(_iprot: TProtocol): String = {
    _iprot.readString()
  }

  @inline private def writeGameTypeField(gameType_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(GameTypeField)
    writeGameTypeValue(gameType_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeGameTypeValue(gameType_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeString(gameType_item)
  }

  @inline private def readCardsValue(_iprot: TProtocol): String = {
    _iprot.readString()
  }

  @inline private def writeCardsField(cards_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(CardsField)
    writeCardsValue(cards_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeCardsValue(cards_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeString(cards_item)
  }

  @inline private def readBaseAmountValue(_iprot: TProtocol): Int = {
    _iprot.readI32()
  }

  @inline private def writeBaseAmountField(baseAmount_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(BaseAmountField)
    writeBaseAmountValue(baseAmount_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeBaseAmountValue(baseAmount_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeI32(baseAmount_item)
  }

  @inline private def readMultiplesValue(_iprot: TProtocol): Int = {
    _iprot.readI32()
  }

  @inline private def writeMultiplesField(multiples_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(MultiplesField)
    writeMultiplesValue(multiples_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeMultiplesValue(multiples_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeI32(multiples_item)
  }

  @inline private def readPreviousUsernameValue(_iprot: TProtocol): String = {
    _iprot.readString()
  }

  @inline private def writePreviousUsernameField(previousUsername_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(PreviousUsernameField)
    writePreviousUsernameValue(previousUsername_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writePreviousUsernameValue(previousUsername_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeString(previousUsername_item)
  }

  @inline private def readPreviousCardsCountValue(_iprot: TProtocol): Int = {
    _iprot.readI32()
  }

  @inline private def writePreviousCardsCountField(previousCardsCount_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(PreviousCardsCountField)
    writePreviousCardsCountValue(previousCardsCount_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writePreviousCardsCountValue(previousCardsCount_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeI32(previousCardsCount_item)
  }

  @inline private def readNextUsernameValue(_iprot: TProtocol): String = {
    _iprot.readString()
  }

  @inline private def writeNextUsernameField(nextUsername_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(NextUsernameField)
    writeNextUsernameValue(nextUsername_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeNextUsernameValue(nextUsername_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeString(nextUsername_item)
  }

  @inline private def readNextCardsCountValue(_iprot: TProtocol): Int = {
    _iprot.readI32()
  }

  @inline private def writeNextCardsCountField(nextCardsCount_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(NextCardsCountField)
    writeNextCardsCountValue(nextCardsCount_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeNextCardsCountValue(nextCardsCount_item: Int, _oprot: TProtocol): Unit = {
    _oprot.writeI32(nextCardsCount_item)
  }

  @inline private def readIsChoosingLandlordValue(_iprot: TProtocol): Boolean = {
    _iprot.readBool()
  }

  @inline private def writeIsChoosingLandlordField(isChoosingLandlord_item: Boolean, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(IsChoosingLandlordField)
    writeIsChoosingLandlordValue(isChoosingLandlord_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeIsChoosingLandlordValue(isChoosingLandlord_item: Boolean, _oprot: TProtocol): Unit = {
    _oprot.writeBool(isChoosingLandlord_item)
  }

  @inline private def readIsLandlordValue(_iprot: TProtocol): Boolean = {
    _iprot.readBool()
  }

  @inline private def writeIsLandlordField(isLandlord_item: Boolean, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(IsLandlordField)
    writeIsLandlordValue(isLandlord_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeIsLandlordValue(isLandlord_item: Boolean, _oprot: TProtocol): Unit = {
    _oprot.writeBool(isLandlord_item)
  }

  @inline private def readTurnToPlayValue(_iprot: TProtocol): Boolean = {
    _iprot.readBool()
  }

  @inline private def writeTurnToPlayField(turnToPlay_item: Boolean, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(TurnToPlayField)
    writeTurnToPlayValue(turnToPlay_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeTurnToPlayValue(turnToPlay_item: Boolean, _oprot: TProtocol): Unit = {
    _oprot.writeBool(turnToPlay_item)
  }


  object Immutable extends ThriftStructCodec3[GameTurnResponse] {
    override def encode(_item: GameTurnResponse, _oproto: TProtocol): Unit = { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): GameTurnResponse = GameTurnResponse.decode(_iprot)
    override lazy val metaData: ThriftStructMetaData[GameTurnResponse] = GameTurnResponse.metaData
  }

  /**
   * The default read-only implementation of GameTurnResponse.  You typically should not need to
   * directly reference this class; instead, use the GameTurnResponse.apply method to construct
   * new instances.
   */
  class Immutable(
      val gameId: Long,
      val gameType: String,
      val cards: String,
      val baseAmount: Int,
      val multiples: Int,
      val previousUsername: String,
      val previousCardsCount: Int,
      val nextUsername: String,
      val nextCardsCount: Int,
      val isChoosingLandlord: Boolean,
      val isLandlord: Boolean,
      val turnToPlay: Boolean,
      override val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends GameTurnResponse {
    def this(
      gameId: Long = 0L,
      gameType: String = "",
      cards: String = "",
      baseAmount: Int = 0,
      multiples: Int = 0,
      previousUsername: String,
      previousCardsCount: Int = 0,
      nextUsername: String,
      nextCardsCount: Int = 0,
      isChoosingLandlord: Boolean = false,
      isLandlord: Boolean = false,
      turnToPlay: Boolean = false
    ) = this(
      gameId,
      gameType,
      cards,
      baseAmount,
      multiples,
      previousUsername,
      previousCardsCount,
      nextUsername,
      nextCardsCount,
      isChoosingLandlord,
      isLandlord,
      turnToPlay,
      Map.empty
    )
  }

  /**
   * This is another Immutable, this however keeps strings as lazy values that are lazily decoded from the backing
   * array byte on read.
   */
  private[this] class LazyImmutable(
      _proto: LazyTProtocol,
      _buf: Array[Byte],
      _start_offset: Int,
      _end_offset: Int,
      val gameId: Long,
      gameTypeOffset: Int,
      cardsOffset: Int,
      val baseAmount: Int,
      val multiples: Int,
      previousUsernameOffset: Int,
      val previousCardsCount: Int,
      nextUsernameOffset: Int,
      val nextCardsCount: Int,
      val isChoosingLandlord: Boolean,
      val isLandlord: Boolean,
      val turnToPlay: Boolean,
      override val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends GameTurnResponse {

    override def write(_oprot: TProtocol): Unit = {
      _oprot match {
        case i: LazyTProtocol => i.writeRaw(_buf, _start_offset, _end_offset - _start_offset)
        case _ => super.write(_oprot)
      }
    }

    lazy val gameType: String =
      if (gameTypeOffset == -1)
        ""
      else {
        _proto.decodeString(_buf, gameTypeOffset)
      }
    lazy val cards: String =
      if (cardsOffset == -1)
        ""
      else {
        _proto.decodeString(_buf, cardsOffset)
      }
    lazy val previousUsername: String =
      if (previousUsernameOffset == -1)
        null
      else {
        _proto.decodeString(_buf, previousUsernameOffset)
      }
    lazy val nextUsername: String =
      if (nextUsernameOffset == -1)
        null
      else {
        _proto.decodeString(_buf, nextUsernameOffset)
      }

    /**
     * Override the super hash code to make it a lazy val rather than def.
     *
     * Calculating the hash code can be expensive, caching it where possible
     * can provide significant performance wins. (Key in a hash map for instance)
     * Usually not safe since the normal constructor will accept a mutable map or
     * set as an arg
     * Here however we control how the class is generated from serialized data.
     * With the class private and the contract that we throw away our mutable references
     * having the hash code lazy here is safe.
     */
    override lazy val hashCode = super.hashCode
  }

  /**
   * This Proxy trait allows you to extend the GameTurnResponse trait with additional state or
   * behavior and implement the read-only methods from GameTurnResponse using an underlying
   * instance.
   */
  trait Proxy extends GameTurnResponse {
    protected def _underlying_GameTurnResponse: GameTurnResponse
    override def gameId: Long = _underlying_GameTurnResponse.gameId
    override def gameType: String = _underlying_GameTurnResponse.gameType
    override def cards: String = _underlying_GameTurnResponse.cards
    override def baseAmount: Int = _underlying_GameTurnResponse.baseAmount
    override def multiples: Int = _underlying_GameTurnResponse.multiples
    override def previousUsername: String = _underlying_GameTurnResponse.previousUsername
    override def previousCardsCount: Int = _underlying_GameTurnResponse.previousCardsCount
    override def nextUsername: String = _underlying_GameTurnResponse.nextUsername
    override def nextCardsCount: Int = _underlying_GameTurnResponse.nextCardsCount
    override def isChoosingLandlord: Boolean = _underlying_GameTurnResponse.isChoosingLandlord
    override def isLandlord: Boolean = _underlying_GameTurnResponse.isLandlord
    override def turnToPlay: Boolean = _underlying_GameTurnResponse.turnToPlay
    override def _passthroughFields = _underlying_GameTurnResponse._passthroughFields
  }
}

trait GameTurnResponse
  extends ThriftStruct
  with scala.Product12[Long, String, String, Int, Int, String, Int, String, Int, Boolean, Boolean, Boolean]
  with java.io.Serializable
{
  import GameTurnResponse._

  def gameId: Long
  def gameType: String
  def cards: String
  def baseAmount: Int
  def multiples: Int
  def previousUsername: String
  def previousCardsCount: Int
  def nextUsername: String
  def nextCardsCount: Int
  def isChoosingLandlord: Boolean
  def isLandlord: Boolean
  def turnToPlay: Boolean

  def _passthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty

  def _1 = gameId
  def _2 = gameType
  def _3 = cards
  def _4 = baseAmount
  def _5 = multiples
  def _6 = previousUsername
  def _7 = previousCardsCount
  def _8 = nextUsername
  def _9 = nextCardsCount
  def _10 = isChoosingLandlord
  def _11 = isLandlord
  def _12 = turnToPlay


  /**
   * Gets a field value encoded as a binary blob using TCompactProtocol.  If the specified field
   * is present in the passthrough map, that value is returned.  Otherwise, if the specified field
   * is known and not optional and set to None, then the field is serialized and returned.
   */
  def getFieldBlob(_fieldId: Short): _root_.scala.Option[TFieldBlob] = {
    lazy val _buff = new TMemoryBuffer(32)
    lazy val _oprot = new TCompactProtocol(_buff)
    _passthroughFields.get(_fieldId) match {
      case blob: _root_.scala.Some[TFieldBlob] => blob
      case _root_.scala.None => {
        val _fieldOpt: _root_.scala.Option[TField] =
          _fieldId match {
            case 1 =>
              if (true) {
                writeGameIdValue(gameId, _oprot)
                _root_.scala.Some(GameTurnResponse.GameIdField)
              } else {
                _root_.scala.None
              }
            case 2 =>
              if (gameType ne null) {
                writeGameTypeValue(gameType, _oprot)
                _root_.scala.Some(GameTurnResponse.GameTypeField)
              } else {
                _root_.scala.None
              }
            case 3 =>
              if (cards ne null) {
                writeCardsValue(cards, _oprot)
                _root_.scala.Some(GameTurnResponse.CardsField)
              } else {
                _root_.scala.None
              }
            case 4 =>
              if (true) {
                writeBaseAmountValue(baseAmount, _oprot)
                _root_.scala.Some(GameTurnResponse.BaseAmountField)
              } else {
                _root_.scala.None
              }
            case 5 =>
              if (true) {
                writeMultiplesValue(multiples, _oprot)
                _root_.scala.Some(GameTurnResponse.MultiplesField)
              } else {
                _root_.scala.None
              }
            case 6 =>
              if (previousUsername ne null) {
                writePreviousUsernameValue(previousUsername, _oprot)
                _root_.scala.Some(GameTurnResponse.PreviousUsernameField)
              } else {
                _root_.scala.None
              }
            case 7 =>
              if (true) {
                writePreviousCardsCountValue(previousCardsCount, _oprot)
                _root_.scala.Some(GameTurnResponse.PreviousCardsCountField)
              } else {
                _root_.scala.None
              }
            case 8 =>
              if (nextUsername ne null) {
                writeNextUsernameValue(nextUsername, _oprot)
                _root_.scala.Some(GameTurnResponse.NextUsernameField)
              } else {
                _root_.scala.None
              }
            case 9 =>
              if (true) {
                writeNextCardsCountValue(nextCardsCount, _oprot)
                _root_.scala.Some(GameTurnResponse.NextCardsCountField)
              } else {
                _root_.scala.None
              }
            case 10 =>
              if (true) {
                writeIsChoosingLandlordValue(isChoosingLandlord, _oprot)
                _root_.scala.Some(GameTurnResponse.IsChoosingLandlordField)
              } else {
                _root_.scala.None
              }
            case 11 =>
              if (true) {
                writeIsLandlordValue(isLandlord, _oprot)
                _root_.scala.Some(GameTurnResponse.IsLandlordField)
              } else {
                _root_.scala.None
              }
            case 12 =>
              if (true) {
                writeTurnToPlayValue(turnToPlay, _oprot)
                _root_.scala.Some(GameTurnResponse.TurnToPlayField)
              } else {
                _root_.scala.None
              }
            case _ => _root_.scala.None
          }
        _fieldOpt match {
          case _root_.scala.Some(_field) =>
            val _data = Arrays.copyOfRange(_buff.getArray, 0, _buff.length)
            _root_.scala.Some(TFieldBlob(_field, _data))
          case _root_.scala.None =>
            _root_.scala.None
        }
      }
    }
  }

  /**
   * Collects TCompactProtocol-encoded field values according to `getFieldBlob` into a map.
   */
  def getFieldBlobs(ids: TraversableOnce[Short]): immutable$Map[Short, TFieldBlob] =
    (ids flatMap { id => getFieldBlob(id) map { id -> _ } }).toMap

  /**
   * Sets a field using a TCompactProtocol-encoded binary blob.  If the field is a known
   * field, the blob is decoded and the field is set to the decoded value.  If the field
   * is unknown and passthrough fields are enabled, then the blob will be stored in
   * _passthroughFields.
   */
  def setField(_blob: TFieldBlob): GameTurnResponse = {
    var gameId: Long = this.gameId
    var gameType: String = this.gameType
    var cards: String = this.cards
    var baseAmount: Int = this.baseAmount
    var multiples: Int = this.multiples
    var previousUsername: String = this.previousUsername
    var previousCardsCount: Int = this.previousCardsCount
    var nextUsername: String = this.nextUsername
    var nextCardsCount: Int = this.nextCardsCount
    var isChoosingLandlord: Boolean = this.isChoosingLandlord
    var isLandlord: Boolean = this.isLandlord
    var turnToPlay: Boolean = this.turnToPlay
    var _passthroughFields = this._passthroughFields
    _blob.id match {
      case 1 =>
        gameId = readGameIdValue(_blob.read)
      case 2 =>
        gameType = readGameTypeValue(_blob.read)
      case 3 =>
        cards = readCardsValue(_blob.read)
      case 4 =>
        baseAmount = readBaseAmountValue(_blob.read)
      case 5 =>
        multiples = readMultiplesValue(_blob.read)
      case 6 =>
        previousUsername = readPreviousUsernameValue(_blob.read)
      case 7 =>
        previousCardsCount = readPreviousCardsCountValue(_blob.read)
      case 8 =>
        nextUsername = readNextUsernameValue(_blob.read)
      case 9 =>
        nextCardsCount = readNextCardsCountValue(_blob.read)
      case 10 =>
        isChoosingLandlord = readIsChoosingLandlordValue(_blob.read)
      case 11 =>
        isLandlord = readIsLandlordValue(_blob.read)
      case 12 =>
        turnToPlay = readTurnToPlayValue(_blob.read)
      case _ => _passthroughFields += (_blob.id -> _blob)
    }
    new Immutable(
      gameId,
      gameType,
      cards,
      baseAmount,
      multiples,
      previousUsername,
      previousCardsCount,
      nextUsername,
      nextCardsCount,
      isChoosingLandlord,
      isLandlord,
      turnToPlay,
      _passthroughFields
    )
  }

  /**
   * If the specified field is optional, it is set to None.  Otherwise, if the field is
   * known, it is reverted to its default value; if the field is unknown, it is removed
   * from the passthroughFields map, if present.
   */
  def unsetField(_fieldId: Short): GameTurnResponse = {
    var gameId: Long = this.gameId
    var gameType: String = this.gameType
    var cards: String = this.cards
    var baseAmount: Int = this.baseAmount
    var multiples: Int = this.multiples
    var previousUsername: String = this.previousUsername
    var previousCardsCount: Int = this.previousCardsCount
    var nextUsername: String = this.nextUsername
    var nextCardsCount: Int = this.nextCardsCount
    var isChoosingLandlord: Boolean = this.isChoosingLandlord
    var isLandlord: Boolean = this.isLandlord
    var turnToPlay: Boolean = this.turnToPlay

    _fieldId match {
      case 1 =>
        gameId = 0L
      case 2 =>
        gameType = ""
      case 3 =>
        cards = ""
      case 4 =>
        baseAmount = 0
      case 5 =>
        multiples = 0
      case 6 =>
        previousUsername = null
      case 7 =>
        previousCardsCount = 0
      case 8 =>
        nextUsername = null
      case 9 =>
        nextCardsCount = 0
      case 10 =>
        isChoosingLandlord = false
      case 11 =>
        isLandlord = false
      case 12 =>
        turnToPlay = false
      case _ =>
    }
    new Immutable(
      gameId,
      gameType,
      cards,
      baseAmount,
      multiples,
      previousUsername,
      previousCardsCount,
      nextUsername,
      nextCardsCount,
      isChoosingLandlord,
      isLandlord,
      turnToPlay,
      _passthroughFields - _fieldId
    )
  }

  /**
   * If the specified field is optional, it is set to None.  Otherwise, if the field is
   * known, it is reverted to its default value; if the field is unknown, it is removed
   * from the passthroughFields map, if present.
   */
  def unsetGameId: GameTurnResponse = unsetField(1)

  def unsetGameType: GameTurnResponse = unsetField(2)

  def unsetCards: GameTurnResponse = unsetField(3)

  def unsetBaseAmount: GameTurnResponse = unsetField(4)

  def unsetMultiples: GameTurnResponse = unsetField(5)

  def unsetPreviousUsername: GameTurnResponse = unsetField(6)

  def unsetPreviousCardsCount: GameTurnResponse = unsetField(7)

  def unsetNextUsername: GameTurnResponse = unsetField(8)

  def unsetNextCardsCount: GameTurnResponse = unsetField(9)

  def unsetIsChoosingLandlord: GameTurnResponse = unsetField(10)

  def unsetIsLandlord: GameTurnResponse = unsetField(11)

  def unsetTurnToPlay: GameTurnResponse = unsetField(12)


  override def write(_oprot: TProtocol): Unit = {
    GameTurnResponse.validate(this)
    _oprot.writeStructBegin(Struct)
    writeGameIdField(gameId, _oprot)
    if (gameType ne null) writeGameTypeField(gameType, _oprot)
    if (cards ne null) writeCardsField(cards, _oprot)
    writeBaseAmountField(baseAmount, _oprot)
    writeMultiplesField(multiples, _oprot)
    if (previousUsername ne null) writePreviousUsernameField(previousUsername, _oprot)
    writePreviousCardsCountField(previousCardsCount, _oprot)
    if (nextUsername ne null) writeNextUsernameField(nextUsername, _oprot)
    writeNextCardsCountField(nextCardsCount, _oprot)
    writeIsChoosingLandlordField(isChoosingLandlord, _oprot)
    writeIsLandlordField(isLandlord, _oprot)
    writeTurnToPlayField(turnToPlay, _oprot)
    if (_passthroughFields.nonEmpty) {
      _passthroughFields.values.foreach { _.write(_oprot) }
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def copy(
    gameId: Long = this.gameId,
    gameType: String = this.gameType,
    cards: String = this.cards,
    baseAmount: Int = this.baseAmount,
    multiples: Int = this.multiples,
    previousUsername: String = this.previousUsername,
    previousCardsCount: Int = this.previousCardsCount,
    nextUsername: String = this.nextUsername,
    nextCardsCount: Int = this.nextCardsCount,
    isChoosingLandlord: Boolean = this.isChoosingLandlord,
    isLandlord: Boolean = this.isLandlord,
    turnToPlay: Boolean = this.turnToPlay,
    _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
  ): GameTurnResponse =
    new Immutable(
      gameId,
      gameType,
      cards,
      baseAmount,
      multiples,
      previousUsername,
      previousCardsCount,
      nextUsername,
      nextCardsCount,
      isChoosingLandlord,
      isLandlord,
      turnToPlay,
      _passthroughFields
    )

  override def canEqual(other: Any): Boolean = other.isInstanceOf[GameTurnResponse]

  override def equals(other: Any): Boolean =
    canEqual(other) &&
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
      _passthroughFields == other.asInstanceOf[GameTurnResponse]._passthroughFields

  override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)

  override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)


  override def productArity: Int = 12

  override def productElement(n: Int): Any = n match {
    case 0 => this.gameId
    case 1 => this.gameType
    case 2 => this.cards
    case 3 => this.baseAmount
    case 4 => this.multiples
    case 5 => this.previousUsername
    case 6 => this.previousCardsCount
    case 7 => this.nextUsername
    case 8 => this.nextCardsCount
    case 9 => this.isChoosingLandlord
    case 10 => this.isLandlord
    case 11 => this.turnToPlay
    case _ => throw new IndexOutOfBoundsException(n.toString)
  }

  override def productPrefix: String = "GameTurnResponse"
}